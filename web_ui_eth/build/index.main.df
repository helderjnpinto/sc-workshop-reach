#lang ll
parts {
  "Alice" = interact {
    deadline = IT_Val UInt,
    getHand = IT_Fun [] UInt,
    informTimeout = IT_Fun [] Null,
    random = IT_Fun [] UInt,
    seeOutcome = IT_Fun [UInt] Null,
    wager = IT_Val UInt},
  "Bob" = interact {
    acceptWager = IT_Fun [UInt] Null,
    getHand = IT_Fun [] UInt,
    informTimeout = IT_Fun [] Null,
    random = IT_Fun [] UInt,
    seeOutcome = IT_Fun [UInt] Null}};

// maps
{
  }
// initialization

{
  }
{
  }
{
  }
{
  }
const v5* = {
  i = 0,
  sign = true};
const v7* = {
  i = 0,
  sign = true};
const v23* = impossible(Cannot inspect value from `forall`);
const v26* = impossible(Cannot inspect value from `forall`);
const v29* = 4 - handBob/26;
const v30* = handAlice/23 + v29;
const v31* = v30 % 3;
const v33* = 0 <= x/31;
const v34* = x/31 < 3;
const v35* = (v33 ? v34 : false);
claim(CT_Assert)(v35, Nothing);
const v37* = impossible(Cannot inspect value from `forall`);
const v40* = 4 - handBob/37;
const v41* = handAlice/37 + v40;
const v42* = v41 % 3;
const v43* = v42 == 1;
claim(CT_Assert)(v43, Nothing);
only(Left "Alice") {
  const v44* = "Alice".interact.deadline;
  const v45* = "Alice".interact.wager;
   };
only(Left "Bob") {
   };
only(Left "Alice") {
  const v47* = selfAddress("Alice", False, 46 )();
  let v48;
  v48 = null;
   };
only(Left "Alice") {
   };
publish(@0)
  .case("Alice").send({
    isClass = False,
    msg = [wager/45, deadline/44],
    pay = [wager/45, ],
    when = true})
  .recv({
    didSend = v56,
    from = v49,
    msg = [v50, v51],
    secs = v55,
    time = v54}){
    timeOrder((None, thisConsensusTime/54 ), (None, thisConsensusSecs/55 ) );
    const v52* = 0;
    const v53* = balance(0)/52 + wager/50;
    checkPay(wager/50, None);
    const v245* = thisConsensusTime/54;
    const v248* = thisConsensusTime/54;
    const v249* = UInt.max - base/248;
    const v250* = v249 - value/51;
    const v251* = v250 >= 0;
    let v252;
    v252 = null;
    const v253* = base/245 + value/51;
    const v254* = <Left v253>;
    commit();
    only(Left "Bob") {
      const v58* = selfAddress("Bob", False, 57 )();
      let v59;
      protect<Null>("Bob".interact.acceptWager(wager/50 ));
      v59 = null;
       };
    only(Left "Bob") {
       };
    publish(@thisConsensusTime/54)
      .timeout(Left v253, {
        only(Left "Alice") {
           };
        only(Left "Bob") {
           };
        publish(@thisConsensusTime/54)
          .case("Alice").send({
            isClass = False,
            msg = [],
            pay = [0, ],
            when = true})
          .case("Bob").send({
            isClass = False,
            msg = [],
            pay = [0, ],
            when = true})
          .recv({
            didSend = v260,
            from = v256,
            msg = [],
            secs = v259,
            time = v258}){
            timeOrder((Some thisConsensusTime/54, thisConsensusTime/258 ), (Some thisConsensusSecs/55, thisConsensusSecs/259 ) );
            const v257* = v53;
            checkPay(0, None);
            const v261* = balance(0)/257;
            const v262* = balance(0)/257;
            const v263* = balance(0)/261 <= balance(0)/262;
            claim(CT_Assert)(v263, Just "balance sufficient for transfer");
            const v264* = balance(0)/257;
            const v265* = balance(0)/264 - balance(0)/261;
            transfer.(balance(0)/261, None).to(v49);
            let v266;
            const v273* = v265;
            const v274* = 0 == balance(0)/273;
            claim(CT_Assert)(v274, Just "balance zero at application exit");
            commit();
            only(Left "Alice") {
              const v268* = selfAddress("Alice", False, 267 )();
              let v269;
              protect<Null>("Alice".interact.informTimeout());
              v269 = null;
               };
            only(Left "Bob") {
              const v271* = selfAddress("Bob", False, 270 )();
              let v272;
              protect<Null>("Bob".interact.informTimeout());
              v272 = null;
               };
            v266 = null;
            exit(); }
           } )
      .case("Bob").send({
        isClass = False,
        msg = [],
        pay = [wager/50, ],
        when = true})
      .recv({
        didSend = v65,
        from = v60,
        msg = [],
        secs = v64,
        time = v63}){
        timeOrder((Some thisConsensusTime/54, thisConsensusTime/63 ), (Some thisConsensusSecs/55, thisConsensusSecs/64 ) );
        const v61* = v53;
        const v62* = balance(0)/61 + wager/50;
        checkPay(wager/50, None);
        loopvar {
          v66 = 1,
          v277 = thisConsensusTime/63,
          v278 = thisConsensusTime/54,
          v279 = v253,
          v280 = thisConsensusSecs/64,
          v281 = thisConsensusSecs/55,
          v282 = thisConsensusSecs/55,
          v283 = v62};
        invariant{
          const v68* = balance(0)/283;
          const v69* = 2 * wager/50;
          const v70* = balance(0)/68 == v69;
          const v72* = 0 <= x/66;
          const v73* = x/66 < 3;
          const v74* = (v72 ? v73 : false);
          const v75* = (v70 ? v74 : false);
          
          return v75; }
        while{
          const v77* = outcome/66 == 1;
          
          return v77; }
        {
          const v194* = thisConsensusTime/277;
          const v197* = thisConsensusTime/277;
          const v198* = UInt.max - base/197;
          const v199* = v198 - value/51;
          const v200* = v199 >= 0;
          let v201;
          v201 = null;
          const v202* = base/194 + value/51;
          const v203* = <Left v202>;
          commit();
          only(Left "Alice") {
            const v79* = selfAddress("Alice", False, 78 )();
            let v80;
            const v81* = protect<UInt>("Alice".interact.getHand());
            const v83* = protect<UInt>("Alice".interact.random());
            const v84* = digest(salt/83, x/81 );
            const v85* = [commitment/84, salt/83 ];
            v80 = null;
             };
          only(Left "Alice") {
             };
          publish(@thisConsensusTime/277)
            .timeout(Left v202, {
              only(Left "Alice") {
                 };
              only(Left "Bob") {
                 };
              publish(@thisConsensusTime/277)
                .case("Alice").send({
                  isClass = False,
                  msg = [],
                  pay = [0, ],
                  when = true})
                .case("Bob").send({
                  isClass = False,
                  msg = [],
                  pay = [0, ],
                  when = true})
                .recv({
                  didSend = v212,
                  from = v205,
                  msg = [],
                  secs = v211,
                  time = v210}){
                  timeOrder((Some thisConsensusTime/277, thisConsensusTime/210 ), (Some thisConsensusSecs/280, thisConsensusSecs/211 ) );
                  const v206* = balance(0)/283;
                  checkPay(0, None);
                  const v207* = v49 == v205;
                  const v208* = v60 == v205;
                  const v209* = (v207 ? true : v208);
                  claim(CT_Require)(v209, Just "sender correct");
                  const v213* = balance(0)/206;
                  const v214* = balance(0)/206;
                  const v215* = balance(0)/213 <= balance(0)/214;
                  claim(CT_Assert)(v215, Just "balance sufficient for transfer");
                  const v216* = balance(0)/206;
                  const v217* = balance(0)/216 - balance(0)/213;
                  transfer.(balance(0)/213, None).to(v60);
                  let v218;
                  const v225* = v217;
                  const v226* = 0 == balance(0)/225;
                  claim(CT_Assert)(v226, Just "balance zero at application exit");
                  commit();
                  only(Left "Alice") {
                    const v220* = selfAddress("Alice", False, 219 )();
                    let v221;
                    protect<Null>("Alice".interact.informTimeout());
                    v221 = null;
                     };
                  only(Left "Bob") {
                    const v223* = selfAddress("Bob", False, 222 )();
                    let v224;
                    protect<Null>("Bob".interact.informTimeout());
                    v224 = null;
                     };
                  v218 = null;
                  exit(); }
                 } )
            .case("Alice").send({
              isClass = False,
              msg = [commitAlice/84],
              pay = [0, ],
              when = true})
            .recv({
              didSend = v92,
              from = v86,
              msg = [v87],
              secs = v91,
              time = v90}){
              timeOrder((Some thisConsensusTime/277, thisConsensusTime/90 ), (Some thisConsensusSecs/280, thisConsensusSecs/91 ) );
              const v88* = balance(0)/283;
              checkPay(0, None);
              const v89* = v49 == v86;
              claim(CT_Require)(v89, Just "sender correct");
              claim(CT_Unknowable "Bob" [DLA_Var _handAlice/81,DLA_Var _saltAlice/83])(false, Nothing);
              const v159* = thisConsensusTime/90;
              const v162* = thisConsensusTime/90;
              const v163* = UInt.max - base/162;
              const v164* = v163 - value/51;
              const v165* = v164 >= 0;
              let v166;
              v166 = null;
              const v167* = base/159 + value/51;
              const v168* = <Left v167>;
              commit();
              only(Left "Bob") {
                const v94* = selfAddress("Bob", False, 93 )();
                let v95;
                const v96* = protect<UInt>("Bob".interact.getHand());
                v95 = null;
                 };
              only(Left "Bob") {
                 };
              publish(@thisConsensusTime/90)
                .timeout(Left v167, {
                  only(Left "Alice") {
                     };
                  only(Left "Bob") {
                     };
                  publish(@thisConsensusTime/90)
                    .case("Alice").send({
                      isClass = False,
                      msg = [],
                      pay = [0, ],
                      when = true})
                    .case("Bob").send({
                      isClass = False,
                      msg = [],
                      pay = [0, ],
                      when = true})
                    .recv({
                      didSend = v177,
                      from = v170,
                      msg = [],
                      secs = v176,
                      time = v175}){
                      timeOrder((Some thisConsensusTime/90, thisConsensusTime/175 ), (Some thisConsensusSecs/91, thisConsensusSecs/176 ) );
                      const v171* = balance(0)/88;
                      checkPay(0, None);
                      const v172* = v49 == v170;
                      const v173* = v60 == v170;
                      const v174* = (v172 ? true : v173);
                      claim(CT_Require)(v174, Just "sender correct");
                      const v178* = balance(0)/171;
                      const v179* = balance(0)/171;
                      const v180* = balance(0)/178 <= balance(0)/179;
                      claim(CT_Assert)(v180, Just "balance sufficient for transfer");
                      const v181* = balance(0)/171;
                      const v182* = balance(0)/181 - balance(0)/178;
                      transfer.(balance(0)/178, None).to(v49);
                      let v183;
                      const v190* = v182;
                      const v191* = 0 == balance(0)/190;
                      claim(CT_Assert)(v191, Just "balance zero at application exit");
                      commit();
                      only(Left "Alice") {
                        const v185* = selfAddress("Alice", False, 184 )();
                        let v186;
                        protect<Null>("Alice".interact.informTimeout());
                        v186 = null;
                         };
                      only(Left "Bob") {
                        const v188* = selfAddress("Bob", False, 187 )();
                        let v189;
                        protect<Null>("Bob".interact.informTimeout());
                        v189 = null;
                         };
                      v183 = null;
                      exit(); }
                     } )
                .case("Bob").send({
                  isClass = False,
                  msg = [handBob/96],
                  pay = [0, ],
                  when = true})
                .recv({
                  didSend = v103,
                  from = v97,
                  msg = [v98],
                  secs = v102,
                  time = v101}){
                  timeOrder((Some thisConsensusTime/90, thisConsensusTime/101 ), (Some thisConsensusSecs/91, thisConsensusSecs/102 ) );
                  const v99* = balance(0)/88;
                  checkPay(0, None);
                  const v100* = v60 == v97;
                  claim(CT_Require)(v100, Just "sender correct");
                  const v124* = thisConsensusTime/101;
                  const v127* = thisConsensusTime/101;
                  const v128* = UInt.max - base/127;
                  const v129* = v128 - value/51;
                  const v130* = v129 >= 0;
                  let v131;
                  v131 = null;
                  const v132* = base/124 + value/51;
                  const v133* = <Left v132>;
                  commit();
                  only(Left "Alice") {
                    const v105* = selfAddress("Alice", False, 104 )();
                    let v106;
                    v106 = null;
                     };
                  only(Left "Alice") {
                     };
                  publish(@thisConsensusTime/101)
                    .timeout(Left v132, {
                      only(Left "Alice") {
                         };
                      only(Left "Bob") {
                         };
                      publish(@thisConsensusTime/101)
                        .case("Alice").send({
                          isClass = False,
                          msg = [],
                          pay = [0, ],
                          when = true})
                        .case("Bob").send({
                          isClass = False,
                          msg = [],
                          pay = [0, ],
                          when = true})
                        .recv({
                          didSend = v142,
                          from = v135,
                          msg = [],
                          secs = v141,
                          time = v140}){
                          timeOrder((Some thisConsensusTime/101, thisConsensusTime/140 ), (Some thisConsensusSecs/102, thisConsensusSecs/141 ) );
                          const v136* = balance(0)/99;
                          checkPay(0, None);
                          const v137* = v49 == v135;
                          const v138* = v60 == v135;
                          const v139* = (v137 ? true : v138);
                          claim(CT_Require)(v139, Just "sender correct");
                          const v143* = balance(0)/136;
                          const v144* = balance(0)/136;
                          const v145* = balance(0)/143 <= balance(0)/144;
                          claim(CT_Assert)(v145, Just "balance sufficient for transfer");
                          const v146* = balance(0)/136;
                          const v147* = balance(0)/146 - balance(0)/143;
                          transfer.(balance(0)/143, None).to(v60);
                          let v148;
                          const v155* = v147;
                          const v156* = 0 == balance(0)/155;
                          claim(CT_Assert)(v156, Just "balance zero at application exit");
                          commit();
                          only(Left "Alice") {
                            const v150* = selfAddress("Alice", False, 149 )();
                            let v151;
                            protect<Null>("Alice".interact.informTimeout());
                            v151 = null;
                             };
                          only(Left "Bob") {
                            const v153* = selfAddress("Bob", False, 152 )();
                            let v154;
                            protect<Null>("Bob".interact.informTimeout());
                            v154 = null;
                             };
                          v148 = null;
                          exit(); }
                         } )
                    .case("Alice").send({
                      isClass = False,
                      msg = [saltAlice/83, handAlice/81],
                      pay = [0, ],
                      when = true})
                    .recv({
                      didSend = v114,
                      from = v107,
                      msg = [v108, v109],
                      secs = v113,
                      time = v112}){
                      timeOrder((Some thisConsensusTime/101, thisConsensusTime/112 ), (Some thisConsensusSecs/102, thisConsensusSecs/113 ) );
                      const v110* = balance(0)/99;
                      checkPay(0, None);
                      const v111* = v49 == v107;
                      claim(CT_Require)(v111, Just "sender correct");
                      const v116* = digest(salt/108, x/109 );
                      const v117* = commitment/87 == v116;
                      claim(CT_Require)(v117, Nothing);
                      const v119* = 4 - handBob/98;
                      const v120* = handAlice/109 + v119;
                      const v121* = v120 % 3;
                      {
                        v66 = outcome/121,
                        v277 = thisConsensusTime/112,
                        v278 = thisConsensusTime/101,
                        v279 = v132,
                        v280 = thisConsensusSecs/113,
                        v281 = thisConsensusSecs/102,
                        v282 = thisConsensusSecs/102,
                        v283 = balance(0)/110}
                      continue; }
                     }
                 }
             }
        const v227* = outcome/66 == 2;
        const v228* = outcome/66 == 0;
        const v229* = (v227 ? true : v228);
        claim(CT_Assert)(v229, Nothing);
        const v230* = 2 * wager/50;
        const v231* = outcome/66 == 2;
        const v232* = (v231 ? v49 : v60);
        const v233* = balance(0)/283;
        const v234* = v230 <= balance(0)/233;
        claim(CT_Assert)(v234, Just "balance sufficient for transfer");
        const v235* = balance(0)/283;
        const v236* = balance(0)/235 - v230;
        transfer.(v230, None).to(v232);
        const v275* = v236;
        const v276* = 0 == balance(0)/275;
        claim(CT_Assert)(v276, Just "balance zero at application exit");
        commit();
        only(Left "Alice") {
          const v238* = selfAddress("Alice", False, 237 )();
          let v239;
          protect<Null>("Alice".interact.seeOutcome(outcome/66 ));
          v239 = null;
           };
        only(Left "Bob") {
          const v241* = selfAddress("Bob", False, 240 )();
          let v242;
          protect<Null>("Bob".interact.seeOutcome(outcome/66 ));
          v242 = null;
           };
        exit(); }
       }
  