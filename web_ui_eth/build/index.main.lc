#lang dk
parts {
  "Alice" = interact {
    deadline = IT_Val UInt,
    getHand = IT_Fun [] UInt,
    informTimeout = IT_Fun [] Null,
    random = IT_Fun [] UInt,
    seeOutcome = IT_Fun [UInt] Null,
    wager = IT_Val UInt},
  "Bob" = interact {
    acceptWager = IT_Fun [UInt] Null,
    getHand = IT_Fun [] UInt,
    informTimeout = IT_Fun [] Null,
    random = IT_Fun [] UInt,
    seeOutcome = IT_Fun [UInt] Null}};

// maps
{
  }
// initialization

{
  }
{
  }
{
  }
{
  }
const v5* = {
  i = 0,
  sign = true};
const v7* = {
  i = 0,
  sign = true};
const v23* = impossible(Cannot inspect value from `forall`);
const v26* = impossible(Cannot inspect value from `forall`);
const v29* = 4 - handBob/26;
const v30* = handAlice/23 + v29;
const v31* = v30 % 3;
const v33* = 0 <= x/31;
const v34* = x/31 < 3;
const v35* = (v33 ? v34 : false);
const eff = claim(CT_Assert)(v35, Nothing);
const v37* = impossible(Cannot inspect value from `forall`);
const v40* = 4 - handBob/37;
const v41* = handAlice/37 + v40;
const v42* = v41 % 3;
const v43* = v42 == 1;
const eff = claim(CT_Assert)(v43, Nothing);
only("Alice") {
  const v44* = "Alice".interact.deadline;
  const v45* = "Alice".interact.wager;
  exit(); };
only("Bob") {
  exit(); };
fluid balance(0) := 0
only("Alice") {
  const v47* = selfAddress("Alice", False, 46 )();
  let v48;
  do {
    v48 = null;
    exit(); };
  exit(); };
only("Alice") {
  exit(); };
publish(@?)
  .case("Alice").send({
    isClass = False,
    msg = [wager/45, deadline/44],
    pay = [wager/45, ],
    when = true})
  .recv({
    didSend = v56,
    from = v49,
    msg = [v50, v51],
    secs = v55,
    time = v54}){
    v52 <- fluid balance(0)
    const v53* = balance(0)/52 + wager/50;
    fluid balance(0) := v53
    const eff = checkPay(wager/50, None);
    fluid thisConsensusTime := thisConsensusTime/54
    fluid thisConsensusSecs := thisConsensusSecs/55
    fluid didPublish := didPublish/56
    liftBoundary();
    v245 <- fluid baseWaitTime
    v248 <- fluid baseWaitTime
    const v249* = UInt.max - base/248;
    const v250* = v249 - value/51;
    const v251* = v250 >= 0;
    let v252;
    do {
      v252 = null;
      exit(); };
    const v253* = base/245 + value/51;
    const v254* = <Left v253>;
    fluid baseWaitTime := v253
    commit();
    only("Bob") {
      const v58* = selfAddress("Bob", False, 57 )();
      let v59;
      do {
        const eff = protect<Null>("Bob".interact.acceptWager(wager/50 ));
        v59 = null;
        exit(); };
      exit(); };
    only("Bob") {
      exit(); };
    publish(@?)
      .timeout(Left v253, {
        only("Alice") {
          exit(); };
        only("Bob") {
          exit(); };
        publish(@?)
          .case("Alice").send({
            isClass = False,
            msg = [],
            pay = [0, ],
            when = true})
          .case("Bob").send({
            isClass = False,
            msg = [],
            pay = [0, ],
            when = true})
          .recv({
            didSend = v260,
            from = v256,
            msg = [],
            secs = v259,
            time = v258}){
            v257 <- fluid balance(0)
            fluid balance(0) := balance(0)/257
            const eff = checkPay(0, None);
            fluid thisConsensusTime := thisConsensusTime/258
            fluid thisConsensusSecs := thisConsensusSecs/259
            fluid didPublish := didPublish/260
            v261 <- fluid balance(0)
            v262 <- fluid balance(0)
            const v263* = balance(0)/261 <= balance(0)/262;
            const eff = claim(CT_Assert)(v263, Just "balance sufficient for transfer");
            v264 <- fluid balance(0)
            const v265* = balance(0)/264 - balance(0)/261;
            fluid balance(0) := v265
            const eff = transfer.(balance(0)/261, None).to(v49);
            liftBoundary();
            let v266;
            v273 <- fluid balance(0)
            const v274* = 0 == balance(0)/273;
            const eff = claim(CT_Assert)(v274, Just "balance zero at application exit");
            commit();
            do {
              only("Alice") {
                const v268* = selfAddress("Alice", False, 267 )();
                let v269;
                do {
                  const eff = protect<Null>("Alice".interact.informTimeout());
                  v269 = null;
                  exit(); };
                exit(); };
              only("Bob") {
                const v271* = selfAddress("Bob", False, 270 )();
                let v272;
                do {
                  const eff = protect<Null>("Bob".interact.informTimeout());
                  v272 = null;
                  exit(); };
                exit(); };
              v266 = null;
              exit(); };
            exit(); }
           } )
      .case("Bob").send({
        isClass = False,
        msg = [],
        pay = [wager/50, ],
        when = true})
      .recv({
        didSend = v65,
        from = v60,
        msg = [],
        secs = v64,
        time = v63}){
        v61 <- fluid balance(0)
        const v62* = balance(0)/61 + wager/50;
        fluid balance(0) := v62
        const eff = checkPay(wager/50, None);
        fluid thisConsensusTime := thisConsensusTime/63
        fluid thisConsensusSecs := thisConsensusSecs/64
        fluid didPublish := didPublish/65
        loopvar {
          v66 = 1};
        invariant{
          v68 <- fluid balance(0)
          const v69* = 2 * wager/50;
          const v70* = balance(0)/68 == v69;
          const v72* = 0 <= x/66;
          const v73* = x/66 < 3;
          const v74* = (v72 ? v73 : false);
          const v75* = (v70 ? v74 : false);
          exit();
          return v75; }
        while{
          const v77* = outcome/66 == 1;
          exit();
          return v77; }
        {
          liftBoundary();
          v194 <- fluid baseWaitTime
          v197 <- fluid baseWaitTime
          const v198* = UInt.max - base/197;
          const v199* = v198 - value/51;
          const v200* = v199 >= 0;
          let v201;
          do {
            v201 = null;
            exit(); };
          const v202* = base/194 + value/51;
          const v203* = <Left v202>;
          fluid baseWaitTime := v202
          commit();
          only("Alice") {
            const v79* = selfAddress("Alice", False, 78 )();
            let v80;
            do {
              const v81* = protect<UInt>("Alice".interact.getHand());
              const v83* = protect<UInt>("Alice".interact.random());
              const v84* = digest(salt/83, x/81 );
              const v85* = [commitment/84, salt/83 ];
              v80 = null;
              exit(); };
            exit(); };
          only("Alice") {
            exit(); };
          publish(@?)
            .timeout(Left v202, {
              only("Alice") {
                exit(); };
              only("Bob") {
                exit(); };
              publish(@?)
                .case("Alice").send({
                  isClass = False,
                  msg = [],
                  pay = [0, ],
                  when = true})
                .case("Bob").send({
                  isClass = False,
                  msg = [],
                  pay = [0, ],
                  when = true})
                .recv({
                  didSend = v212,
                  from = v205,
                  msg = [],
                  secs = v211,
                  time = v210}){
                  v206 <- fluid balance(0)
                  fluid balance(0) := balance(0)/206
                  const eff = checkPay(0, None);
                  const v207* = v49 == v205;
                  const v208* = v60 == v205;
                  const v209* = (v207 ? true : v208);
                  const eff = claim(CT_Require)(v209, Just "sender correct");
                  fluid thisConsensusTime := thisConsensusTime/210
                  fluid thisConsensusSecs := thisConsensusSecs/211
                  fluid didPublish := didPublish/212
                  v213 <- fluid balance(0)
                  v214 <- fluid balance(0)
                  const v215* = balance(0)/213 <= balance(0)/214;
                  const eff = claim(CT_Assert)(v215, Just "balance sufficient for transfer");
                  v216 <- fluid balance(0)
                  const v217* = balance(0)/216 - balance(0)/213;
                  fluid balance(0) := v217
                  const eff = transfer.(balance(0)/213, None).to(v60);
                  liftBoundary();
                  let v218;
                  v225 <- fluid balance(0)
                  const v226* = 0 == balance(0)/225;
                  const eff = claim(CT_Assert)(v226, Just "balance zero at application exit");
                  commit();
                  do {
                    only("Alice") {
                      const v220* = selfAddress("Alice", False, 219 )();
                      let v221;
                      do {
                        const eff = protect<Null>("Alice".interact.informTimeout());
                        v221 = null;
                        exit(); };
                      exit(); };
                    only("Bob") {
                      const v223* = selfAddress("Bob", False, 222 )();
                      let v224;
                      do {
                        const eff = protect<Null>("Bob".interact.informTimeout());
                        v224 = null;
                        exit(); };
                      exit(); };
                    v218 = null;
                    exit(); };
                  exit(); }
                 } )
            .case("Alice").send({
              isClass = False,
              msg = [commitAlice/84],
              pay = [0, ],
              when = true})
            .recv({
              didSend = v92,
              from = v86,
              msg = [v87],
              secs = v91,
              time = v90}){
              v88 <- fluid balance(0)
              fluid balance(0) := balance(0)/88
              const eff = checkPay(0, None);
              const v89* = v49 == v86;
              const eff = claim(CT_Require)(v89, Just "sender correct");
              fluid thisConsensusTime := thisConsensusTime/90
              fluid thisConsensusSecs := thisConsensusSecs/91
              fluid didPublish := didPublish/92
              liftBoundary();
              const eff = claim(CT_Unknowable "Bob" [DLA_Var _handAlice/81,DLA_Var _saltAlice/83])(false, Nothing);
              v159 <- fluid baseWaitTime
              v162 <- fluid baseWaitTime
              const v163* = UInt.max - base/162;
              const v164* = v163 - value/51;
              const v165* = v164 >= 0;
              let v166;
              do {
                v166 = null;
                exit(); };
              const v167* = base/159 + value/51;
              const v168* = <Left v167>;
              fluid baseWaitTime := v167
              commit();
              only("Bob") {
                const v94* = selfAddress("Bob", False, 93 )();
                let v95;
                do {
                  const v96* = protect<UInt>("Bob".interact.getHand());
                  v95 = null;
                  exit(); };
                exit(); };
              only("Bob") {
                exit(); };
              publish(@?)
                .timeout(Left v167, {
                  only("Alice") {
                    exit(); };
                  only("Bob") {
                    exit(); };
                  publish(@?)
                    .case("Alice").send({
                      isClass = False,
                      msg = [],
                      pay = [0, ],
                      when = true})
                    .case("Bob").send({
                      isClass = False,
                      msg = [],
                      pay = [0, ],
                      when = true})
                    .recv({
                      didSend = v177,
                      from = v170,
                      msg = [],
                      secs = v176,
                      time = v175}){
                      v171 <- fluid balance(0)
                      fluid balance(0) := balance(0)/171
                      const eff = checkPay(0, None);
                      const v172* = v49 == v170;
                      const v173* = v60 == v170;
                      const v174* = (v172 ? true : v173);
                      const eff = claim(CT_Require)(v174, Just "sender correct");
                      fluid thisConsensusTime := thisConsensusTime/175
                      fluid thisConsensusSecs := thisConsensusSecs/176
                      fluid didPublish := didPublish/177
                      v178 <- fluid balance(0)
                      v179 <- fluid balance(0)
                      const v180* = balance(0)/178 <= balance(0)/179;
                      const eff = claim(CT_Assert)(v180, Just "balance sufficient for transfer");
                      v181 <- fluid balance(0)
                      const v182* = balance(0)/181 - balance(0)/178;
                      fluid balance(0) := v182
                      const eff = transfer.(balance(0)/178, None).to(v49);
                      liftBoundary();
                      let v183;
                      v190 <- fluid balance(0)
                      const v191* = 0 == balance(0)/190;
                      const eff = claim(CT_Assert)(v191, Just "balance zero at application exit");
                      commit();
                      do {
                        only("Alice") {
                          const v185* = selfAddress("Alice", False, 184 )();
                          let v186;
                          do {
                            const eff = protect<Null>("Alice".interact.informTimeout());
                            v186 = null;
                            exit(); };
                          exit(); };
                        only("Bob") {
                          const v188* = selfAddress("Bob", False, 187 )();
                          let v189;
                          do {
                            const eff = protect<Null>("Bob".interact.informTimeout());
                            v189 = null;
                            exit(); };
                          exit(); };
                        v183 = null;
                        exit(); };
                      exit(); }
                     } )
                .case("Bob").send({
                  isClass = False,
                  msg = [handBob/96],
                  pay = [0, ],
                  when = true})
                .recv({
                  didSend = v103,
                  from = v97,
                  msg = [v98],
                  secs = v102,
                  time = v101}){
                  v99 <- fluid balance(0)
                  fluid balance(0) := balance(0)/99
                  const eff = checkPay(0, None);
                  const v100* = v60 == v97;
                  const eff = claim(CT_Require)(v100, Just "sender correct");
                  fluid thisConsensusTime := thisConsensusTime/101
                  fluid thisConsensusSecs := thisConsensusSecs/102
                  fluid didPublish := didPublish/103
                  liftBoundary();
                  v124 <- fluid baseWaitTime
                  v127 <- fluid baseWaitTime
                  const v128* = UInt.max - base/127;
                  const v129* = v128 - value/51;
                  const v130* = v129 >= 0;
                  let v131;
                  do {
                    v131 = null;
                    exit(); };
                  const v132* = base/124 + value/51;
                  const v133* = <Left v132>;
                  fluid baseWaitTime := v132
                  commit();
                  only("Alice") {
                    const v105* = selfAddress("Alice", False, 104 )();
                    let v106;
                    do {
                      v106 = null;
                      exit(); };
                    exit(); };
                  only("Alice") {
                    exit(); };
                  publish(@?)
                    .timeout(Left v132, {
                      only("Alice") {
                        exit(); };
                      only("Bob") {
                        exit(); };
                      publish(@?)
                        .case("Alice").send({
                          isClass = False,
                          msg = [],
                          pay = [0, ],
                          when = true})
                        .case("Bob").send({
                          isClass = False,
                          msg = [],
                          pay = [0, ],
                          when = true})
                        .recv({
                          didSend = v142,
                          from = v135,
                          msg = [],
                          secs = v141,
                          time = v140}){
                          v136 <- fluid balance(0)
                          fluid balance(0) := balance(0)/136
                          const eff = checkPay(0, None);
                          const v137* = v49 == v135;
                          const v138* = v60 == v135;
                          const v139* = (v137 ? true : v138);
                          const eff = claim(CT_Require)(v139, Just "sender correct");
                          fluid thisConsensusTime := thisConsensusTime/140
                          fluid thisConsensusSecs := thisConsensusSecs/141
                          fluid didPublish := didPublish/142
                          v143 <- fluid balance(0)
                          v144 <- fluid balance(0)
                          const v145* = balance(0)/143 <= balance(0)/144;
                          const eff = claim(CT_Assert)(v145, Just "balance sufficient for transfer");
                          v146 <- fluid balance(0)
                          const v147* = balance(0)/146 - balance(0)/143;
                          fluid balance(0) := v147
                          const eff = transfer.(balance(0)/143, None).to(v60);
                          liftBoundary();
                          let v148;
                          v155 <- fluid balance(0)
                          const v156* = 0 == balance(0)/155;
                          const eff = claim(CT_Assert)(v156, Just "balance zero at application exit");
                          commit();
                          do {
                            only("Alice") {
                              const v150* = selfAddress("Alice", False, 149 )();
                              let v151;
                              do {
                                const eff = protect<Null>("Alice".interact.informTimeout());
                                v151 = null;
                                exit(); };
                              exit(); };
                            only("Bob") {
                              const v153* = selfAddress("Bob", False, 152 )();
                              let v154;
                              do {
                                const eff = protect<Null>("Bob".interact.informTimeout());
                                v154 = null;
                                exit(); };
                              exit(); };
                            v148 = null;
                            exit(); };
                          exit(); }
                         } )
                    .case("Alice").send({
                      isClass = False,
                      msg = [saltAlice/83, handAlice/81],
                      pay = [0, ],
                      when = true})
                    .recv({
                      didSend = v114,
                      from = v107,
                      msg = [v108, v109],
                      secs = v113,
                      time = v112}){
                      v110 <- fluid balance(0)
                      fluid balance(0) := balance(0)/110
                      const eff = checkPay(0, None);
                      const v111* = v49 == v107;
                      const eff = claim(CT_Require)(v111, Just "sender correct");
                      fluid thisConsensusTime := thisConsensusTime/112
                      fluid thisConsensusSecs := thisConsensusSecs/113
                      fluid didPublish := didPublish/114
                      const v116* = digest(salt/108, x/109 );
                      const v117* = commitment/87 == v116;
                      const eff = claim(CT_Require)(v117, Nothing);
                      const v119* = 4 - handBob/98;
                      const v120* = handAlice/109 + v119;
                      const v121* = v120 % 3;
                      {
                        v66 = outcome/121}
                      continue; }
                     }
                 }
             }
        const v227* = outcome/66 == 2;
        const v228* = outcome/66 == 0;
        const v229* = (v227 ? true : v228);
        const eff = claim(CT_Assert)(v229, Nothing);
        const v230* = 2 * wager/50;
        const v231* = outcome/66 == 2;
        const v232* = (v231 ? v49 : v60);
        v233 <- fluid balance(0)
        const v234* = v230 <= balance(0)/233;
        const eff = claim(CT_Assert)(v234, Just "balance sufficient for transfer");
        v235 <- fluid balance(0)
        const v236* = balance(0)/235 - v230;
        fluid balance(0) := v236
        const eff = transfer.(v230, None).to(v232);
        liftBoundary();
        v275 <- fluid balance(0)
        const v276* = 0 == balance(0)/275;
        const eff = claim(CT_Assert)(v276, Just "balance zero at application exit");
        commit();
        only("Alice") {
          const v238* = selfAddress("Alice", False, 237 )();
          let v239;
          do {
            const eff = protect<Null>("Alice".interact.seeOutcome(outcome/66 ));
            v239 = null;
            exit(); };
          exit(); };
        only("Bob") {
          const v241* = selfAddress("Bob", False, 240 )();
          let v242;
          do {
            const eff = protect<Null>("Bob".interact.seeOutcome(outcome/66 ));
            v242 = null;
            exit(); };
          exit(); };
        exit(); }
       }
  